///
/// Directly graph-related functions.
///

#include <stdio.h>
#include <stdbool.h>
#include "functionality.h"
#include "utils.h"

/******** PRECHECK ********/

// Determine whether the graph can fiber.
bool graph_can_fiber(arr2d_fixed adj) {
    int n = adj.len;

    int e = 0;
    for (int i=0; i<n; i++)
        for (int j=i+1; j<n; j++)
            if (get_arrf(adj,i,j))
                e++;

    // check 0 <= k2(G) = 1 - v/2 + e/4
    if (2*n > e+4) return false;

    // check connectedness and treeness
    bool conn = 1-n+e >= 0;
    bool tree = 1-n+e == 0;
    if (n > 2 && !conn) return false;
    if (n > 3 && tree) return false;

    return true;
}

/******** HYPERBOLICITY ********/

// Check whether the RACG generated by the given graph is hyperbolic, that is, whether every 4-cycle in the graph is divided into triangles.
bool is_graph_hyperbolic(arr2d_fixed adj) {
    int n = adj.len;
    int verts[n];

    // Check for every non-edge (i,j) whether i,j have distance 2
    for (int i=0; i<n; i++) {
        for (int j=i+1; j<n; j++) {
            if (get_arrf(adj,i,j)) continue;

            // Get every vertex both connected to i and j
            int count = 0;
            for (int v=i+1; v<n; v++) {
                if (get_arrf(adj,i,v) & get_arrf(adj,j,v)) { // j != v as adj[j,j] = 0
                    verts[count]=v;
                    count++;
                }
            }
            // Check whether all these vertices are pairwise connected. If not, G contains ZxZ.
            bool hyp = true;
            for (int k=0; k<count; k++) {
                for (int l=k+1; l<count; l++) {
                    hyp &= get_arrf(adj,verts[k],verts[l]);
                }
            }
            if (!hyp)
                return false;
        }
    }

    return true;
}

/******** GRAPH ISOMETRIES ********/

arr2d_fixed get_isometries_impl(arr2d_fixed adj, arr2d_fixed isometries, int current_iso[], int level);

// Calculate all isometries of the graph.
// The graph is given by its adjacency matrix in contiguous form, n successive entries making a row.
arr2d_fixed get_isometries(arr2d_fixed adj) {
    int n = adj.len;
    int current_iso[n];
    memset(current_iso,0,n*sizeof(int));
    arr2d_fixed result = arr2d_fixed_create_empty(n, 10);
    return get_isometries_impl(adj, result, current_iso, 0);
}

arr2d_fixed get_isometries_impl(arr2d_fixed adj, arr2d_fixed isometries, int current_iso[], int level) {
    int n = adj.len;

    // Add isometry
    if (level == n)
        return append_arrf(isometries, current_iso);

    // insert 'i' somewhere into current_iso
    for (int i=0; i<n; i++) {
        // check whether current_iso already contains i
        bool contains_i = false;
        for (int j=0; j<level; j++) {
            if (current_iso[j] == i) {
                contains_i = true;
                break;
            }
        }

        if (contains_i)
            continue;

        // check whether adding i at position level would preserve all edges
        bool is_ok = true;
        for (int j=0; j<level; j++) {
            if (get_arrf(adj,level,j) != get_arrf(adj,i,current_iso[j])) {
                is_ok = false;
                break;
            }
        }

        // add i to current_iso and recurse
        if (is_ok) {
            current_iso[level] = i;
            isometries = get_isometries_impl(adj, isometries, current_iso, level+1);
        }
    }

    return isometries;
}
///
/// Directly graph-related functions.
///

#include <stdio.h>
#include <stdbool.h>
#include "functionality.h"
#include "utils.h"

/******** PRECHECK ********/

// Determine whether the graph can fiber.
bool graph_can_fiber(arr2d_fixed adj) {
    int n = adj.len;

    int e = 0;
    for (int i=0; i<n; i++)
        for (int j=i+1; j<n; j++)
            if (get_arrf(adj,i,j))
                e++;

    // check 0 <= k2(G) = 1 - v/2 + e/4
    if (2*n > e+4) return false;

    // check connectedness and treeness
    bool conn = graph_connected(adj);
    bool tree = 1-n+e == 0;
    if (n > 2 && !conn) return false;
    if (n > 3 && tree) return false;

    return true;
}

/******** HYPERBOLICITY ********/

// Check whether the RACG generated by the given graph is hyperbolic, that is, whether every 4-cycle in the graph is divided into triangles.
bool is_graph_hyperbolic(arr2d_fixed adj) {
    int n = adj.len;
    int verts[n];

    // Check for every non-edge (i,j) whether i,j have distance 2
    for (int i=0; i<n; i++) {
        for (int j=i+1; j<n; j++) {
            if (get_arrf(adj,i,j)) continue;

            // Get every vertex both connected to i and j
            int count = 0;
            for (int v=i+1; v<n; v++) {
                if (get_arrf(adj,i,v) & get_arrf(adj,j,v)) { // j != v as adj[j,j] = 0
                    verts[count]=v;
                    count++;
                }
            }
            // Check whether all these vertices are pairwise connected. If not, G contains ZxZ.
            bool hyp = true;
            for (int k=0; k<count; k++) {
                for (int l=k+1; l<count; l++) {
                    hyp &= get_arrf(adj,verts[k],verts[l]);
                }
            }
            if (!hyp)
                return false;
        }
    }

    return true;
}

/******** GRAPH ISOMETRIES ********/

arr2d_fixed get_isometries_impl(arr2d_fixed adj, arr2d_fixed isometries, int current_iso[], int image_bits, int level);

// Calculate all isometries of the graph.
// The graph is given by its adjacency matrix in contiguous form, n successive entries making a row.
arr2d_fixed get_isometries(arr2d_fixed adj) {
    int n = adj.len;
    int current_iso[n];
    memset(current_iso,0,n*sizeof(int));
    arr2d_fixed result = arr2d_fixed_create_empty(n, 10);
    return get_isometries_impl(adj, result, current_iso, 0, 0);
}

arr2d_fixed get_isometries_impl(arr2d_fixed adj, arr2d_fixed isometries, int current_iso[], int image_bits, int level) {
    int n = adj.len;

    // Add isometry
    if (level == n)
        return append_arrf(isometries, current_iso);

    // insert 'i' somewhere into current_iso
    for (int i=0; i<n; i++) {
        // check whether current_iso already contains i
        if ((image_bits >> i) & 1) continue;

        // check whether adding i at position level would preserve all edges
        bool is_ok = true;
        for (int j=0; j<level; j++) {
            if (get_arrf(adj,level,j) != get_arrf(adj,i,current_iso[j])) {
                is_ok = false;
                break;
            }
        }

        // add i to current_iso and recurse
        if (is_ok) {
            current_iso[level] = i;
            int new_image = image_bits + (1 << i);
            isometries = get_isometries_impl(adj, isometries, current_iso, new_image, level+1);
        }
    }

    return isometries;
}

/******* GRAPH CONNECTEDNESS *******/

#define MAX_VERTS 32
typedef struct {
    int queue[MAX_VERTS];
    int front; // = -1
    int rear; // = -1
} bfs_queue;

bool queue_empty(bfs_queue queue) {
    return queue.front == -1 || queue.front > queue.rear;
}

bfs_queue queue_insert(bfs_queue queue, int v) {
    bfs_queue new = queue;

    if (new.front == -1)
        new.front = 0;
    new.rear++;
    new.queue[new.rear] = v;
    return new;
}

bfs_queue queue_delete(bfs_queue queue, int* v) {
    bfs_queue new = queue;

    *v = new.queue[new.front];
    new.front++;
    return new;
}

bool graph_connected(arr2d_fixed adj) {
    int n = adj.len;
    int vertices[n];
    for (int i=0; i<n; i++) vertices[i] = i;
    return subgraph_connected(adj, n, vertices);
}

bool subgraph_connected(arr2d_fixed adj, int sub_size, int vertices[]) {
    int visited = 0;
    int all = (1 << sub_size) - 1;

    int v = 0;
    bfs_queue queue = {.front = -1, .rear = -1};
    queue = queue_insert(queue, v); // we label the vertices (0, ..., sub_size-1) and then translate via `vertices`
    visited += (1 << v);

    // Do BFS
    while (!queue_empty(queue) && visited != all) {
        queue = queue_delete(queue, &v);
        for (int i=0; i<sub_size; i++) { // add adjacent unvisited vertices to queue
            if (!((visited >> i) & 1) && get_arrf(adj,vertices[v],vertices[i])) {
                visited += (1 << i);
                queue = queue_insert(queue, i);
            }
        }
    }

    return visited == all;
}